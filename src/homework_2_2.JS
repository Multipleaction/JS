undefined + 1; // NaN
// undefined: Значення undefined це спеціальне значення, яке вказує на те, що змінна не має присвоєного значення або що функція не повернула значення
// 1: Це число, яке ми додаємо до undefined
// Виконання операції: JavaScript спробує виконати додавання числа до undefined
// Результат: Оскільки undefined не може бути конвертоване в число, результатом буде NaN

//******************************************************************************************************************* */

'true' == true; // false
// 'true': Це рядок, представляючий слово "true"
// true: Це логічне значення true
// Виконання операції: JavaScript спробує автоматично перетворити типи для порівняння
// Перетворення 'true' в число: Рядок 'true' не може бути точно перетворений в число, тому воно стає NaN при конвертації в число
// Порівняння числа NaN і 1: Любе порівняння з NaN повертає false
// Результат: Результатом є false, оскільки NaN не дорівнює 1

// ******************************************************************************************************************* */

false == 'false'; // false
// Так само як і попередній приклад
// Результат: Результатом є false

// ******************************************************************************************************************* */

null == ''; // false
// null: Значення, що вказує на відсутність значення
// '': Це порожній рядок
// Виконання операції: JavaScript спробує порівняти обидва операнди
// Результат: null та '' не є однаковими типами, тому результатом буде false

// ******************************************************************************************************************* */

3 ** (9 / 3); // 27
// Виконання операції:
// 9 / 3: Виконується операція ділення (операції в дужках мають найвищий пріоритет). Ділення числа 9 на число 3 дає результат 3. Отже, вираз стає 3 ** 3
// Піднесення числа 3 до третьої степені
// Результат: 27

// ******************************************************************************************************************* */

!!'false' == !!'true'; // true
// !!: Оператор, що використовується для подвійної зміни типу на булевий
// 'false': Рядкове значення 'false'
// 'true': Рядкове значення 'true'
// Перша подвійна зміна типу: Перше ! зробить з рядкового значення булеве false, а друге ! робить із false значення true. Результат буде true.
// Друга подвійна зміна типу: Перше ! зробить з рядкового значення булеве false, а друге ! робить із false значення true
// Виконання операції: Порівняння двох булевих значень
// Результат: Порівняння true з true повертає true

// ******************************************************************************************************************* */

0 || ('0' && 1); // 1
// Пріоритетність операторів:
// 1. Оператор && (логічне і) має вищий пріоритет, ніж || (логічне або)
// 2. Оператор || (логічне або) має нижчий пріоритет

// Виконання операції:
// Виконується операція && (логічне і) між рядковим значенням '0' та числом 1
// Рядкове значення '0' перетворюється в булеве значення true, оскільки це непорожній рядок
// Потім виконується операція || (логічне або) між числом 0 та true
// Оператор || поверне перше істинне значення, яке є true (число 1)
// Hезультатом буде число 1

// ******************************************************************************************************************* */

1 < 2 < 3; // true
// Оператори порівняння виконуються зліва направо
// Виконання операції:
// 1 < 2: Перше порівняння перевіряє чи число 1 менше за число 2. Результат - true
// true < 3: Друге порівняння перевіряє, чи true (яке автоматично конвертується в число 1) менше за число 3. Результат - true
// Результат: true < 3 повертає true

// ******************************************************************************************************************* */

'foo' + +(+'bar'); // 'fooNaN'
// 'bar': Рядкове значення 'bar'.
// Виконання операції:
// +'bar': Унарний плюс спробує перетворити 'bar' в число. Оскільки 'bar' не може бути коректно перетворено в число, результат буде NaN
// +(+'bar'): Унарний плюс спробує знову перетворити результат попередньої операції в число, також дасть NaN
// 'foo' + NaN: Додавання рядка 'foo' до NaN
// Результат: 'fooNaN'.

// ******************************************************************************************************************* */

3 ** 2 / 3; // 3
// Виконання операції:
// 3 ** 2: Піднесення числа 3 до степеня 2.
// 3 ** 2 = 9
// 9 / 3: Ділення результату попередньої операції на число 3.
// 9 / 3 = 3
// Результат: 3

// ******************************************************************************************************************* */

// *** Тут я замахався розписувати і з твого дозволу продовжу вже коротше, бо і так голова кипить)) ****

1 < 2 > 3; // false
// порівняння зліва направо : 1 < 2: true (оскільки 1 менше за 2)
// true > 3: false (оскільки true конвертується в 1, і 1 не більше за 3)

(+null == false) < 1; // false
// +null == false,  Оператор + конвертує null у число, тому що null перетворюється в 0
// Результатом цього порівняння є true, оскільки false теж конвертується в 0
// Результат першого порівняння (тобто true) порівнюється з числом 1: Ми отримуємо true < 1
// 1 < 1 дає false

(false && true) || true; // true
// false && true: Логічне І повертає false, оскільки обидва операнди мають бути істинними для того, щоб вираз був істинним
// Результат першого виразу (false) об'єднується з другим операндом ||, який є true
//  Логічне АБО повертає true, якщо хоча б один з операндів є істинним

false && (true || true); // false
// В дужках виконується операця true || true, логічне АБО повертає true, тому що хоча б один з операндів є істинним
// По ітогу ми маєио false && true. Операція логічного І поверне false, оскільки хоча б один з операндів є хибним

(+null == false) < 1 ** 5; // false
//Оператор + конвертує null в 0, тому ми отримуємо порівняння 0 == false
// Результатом цього порівняння є true, оскільки false також конвертується в 0
// 1 ** 5: Оператор піднесення до степеня підносить число 1 до степеня 5, тому отримуємо 1
// true < 1 : Оскільки true у контексті порівнянь конвертується в 1, ми  порівнюємо 1 < 1

// Запусти щоб перевірити
const valuesToCheck = [
	undefined + 1,
	'true' == true,
	false == 'false',
	null == '',
	3 ** (9 / 3),
	!!'false' == !!'true',
	0 || ('0' && 1),
	1 < 2 < 3,
	'foo' + +(+'bar'),
	3 ** 2 / 3,
	1 < 2 > 3,
	(+null == false) < 1,
	(false && true) || true,
	false && (true || true),
	(+null == false) < 1 ** 5,
];
const logResult = (values) => {
	values.forEach((value) => {
		console.log(value);
	});
};
logResult(valuesToCheck);
